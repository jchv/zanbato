package golang

import (
	"testing"

	"github.com/jchv/zanbato/kaitai"
	"github.com/jchv/zanbato/kaitai/expr"
	"github.com/jchv/zanbato/kaitai/types"
	"github.com/stretchr/testify/assert"
)

func Test(t *testing.T) {
	tests := []struct {
		Name   string
		Struct *kaitai.Struct
		Source string
	}{
		{
			Name: "Attrs",
			Struct: &kaitai.Struct{
				ID: "attrs",
				Seq: []*kaitai.Attr{
					{ID: "magic", Type: types.Type{TypeRef: &types.TypeRef{Kind: types.Bytes, Bytes: &types.BytesType{Size: expr.MustParseExpr("4")}}}, Contents: []byte{0x7f, 'E', 'L', 'F'}},
					{ID: "count", Type: types.Type{TypeRef: &types.TypeRef{Kind: types.S8le}}},
					// TODO: implement repeated fields.
					// {ID: "entries", Type: kaitai.Type{Kind: kaitai.S2le}, Repeat: kaitai.RepeatExpr{CountExpr: kaitai.MustParseExpr("count")}},
				},
			},
			Source: `// Generated by Zanbato. Do not edit!

package test

import (
	bytes "bytes"
	kaitai "github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
)

type Attrs struct {
	Magic []byte
	Count int64
}

func (this *Attrs) Read(io *kaitai.Stream) (err error) {
	tmp1, err := io.ReadBytes(int(4))
	if err != nil {
		return err
	}
	this.Magic = (tmp1)
	if !bytes.Equal(tmp1, []byte{0x7f, 0x45, 0x4c, 0x46}) {
		return kaitai.NewValidationNotEqualError([]byte{0x7f, 0x45, 0x4c, 0x46}, tmp1, io, "") // TODO: set srcPath
	}
	tmp2, err := io.ReadS8le()
	if err != nil {
		return err
	}
	this.Count = (tmp2)
	return nil
}

func (this *Attrs) ReadBE(io *kaitai.Stream) (err error) {
	return this.Read(io)
}

func (this *Attrs) ReadLE(io *kaitai.Stream) (err error) {
	return this.Read(io)
}

`,
		},
		{
			Name: "Expr",
			Struct: &kaitai.Struct{
				ID: "expr",
				Seq: []*kaitai.Attr{
					{ID: "a", Type: types.Type{TypeRef: &types.TypeRef{Kind: types.S2le}}},
					{ID: "b", Type: types.Type{TypeRef: &types.TypeRef{Kind: types.Bytes, Bytes: &types.BytesType{Size: expr.MustParseExpr("a == 1 ? 2 : 4")}}}},
					// TODO: implement repeated fields.
					// {ID: "entries", Type: kaitai.Type{Kind: kaitai.S2le}, Repeat: kaitai.RepeatExpr{CountExpr: kaitai.MustParseExpr("count")}},
				},
			},
			Source: `// Generated by Zanbato. Do not edit!

package test

import (
	kaitai "github.com/kaitai-io/kaitai_struct_go_runtime/kaitai"
)

type Expr struct {
	A int16
	B []byte
}

func (this *Expr) Read(io *kaitai.Stream) (err error) {
	tmp1, err := io.ReadS2le()
	if err != nil {
		return err
	}
	this.A = (tmp1)
	tmp2, err := io.ReadBytes(int((func() (int) { if ((int)(this.A) == (int)(1)) { return (int)(2) } else { return (int)(4) } }())))
	if err != nil {
		return err
	}
	this.B = (tmp2)
	return nil
}

func (this *Expr) ReadBE(io *kaitai.Stream) (err error) {
	return this.Read(io)
}

func (this *Expr) ReadLE(io *kaitai.Stream) (err error) {
	return this.Read(io)
}

`,
		},
	}

	for _, test := range tests {
		t.Run(test.Name, func(t *testing.T) {
			artifacts := NewEmitter("test", nil).Emit("test", test.Struct)
			assert.Equal(t, test.Source, string(artifacts[0].Body))
		})
	}
}
